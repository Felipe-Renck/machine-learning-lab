name: minikube-test
on: workflow_dispatch

jobs:
  minikube-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - name: install-minikube
        run: |
          curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
          && chmod +x minikube \
          && sudo cp minikube /usr/local/bin && rm minikube
      - name: start-minikube
        run: |
          minikube start --force \
          --driver=docker \
          --kubernetes-version v1.14.8 \
          --embed-certs \
          --apiserver-ips=$(hostname -I | cut -d ' ' -f 1)
      # set the SERVICE_HOST to the IP of the Cluster Node (corresponds to minikube container. Since minikube uses hostmode the started test container can reach the ip address)
      - name: set-service-host
        run: echo "::set-env name=LAB_SERVICE_HOST::$(minikube node list | cut -d $'\t' -f 2)"
        # new syntax: echo "LAB_SERVICE_HOST=$(minikube node list | cut -d $'\t' -f 2)" >> "$GITHUB_ENV"
      # tunnel the minikube kube-server port because it only allows connections from localhost. Hence, you cannot connect from another container
      # minikube_ssh_port is the mapped port to minikube's port :22
      # host_ip is the ip address of the machine/container this script here runs on (e.g. the act container)
      - name: start-kube-tunnel-with-ssh
        run: |
          minikube_ssh_port=$(docker inspect minikube | jq '.[0].NetworkSettings.Ports."22/tcp"[0].HostPort | tonumber')
          host_ip=$(hostname -I | cut -d ' ' -f 1)
          ssh -fNt -o StrictHostKeyChecking=no \
            -i ~/.minikube/machines/minikube/id_rsa \
            -p $minikube_ssh_port \
            -L $host_ip:5000:localhost:8443 \
            docker@127.0.0.1
          # sleep just to be safe that the tunnel has some time to be created
          sleep 5
          # test the connection or abort already here
          curl $host_ip:5000
      # modify kube config so that the hostip and tunneled port are used instead of localhost:public port,
      - name: modify-kube-config
        run: sed -i -E 's/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+/'"$(hostname -I | cut -d ' ' -f 1)":5000'/g' ~/.kube/config
      # create a volume containing the kube config that was generated by minikube and can mounted by the ML Lab container
      - name: create-kube-config-volume
        run: docker run --rm -v kube-config:/kube-config --env KUBE_DATA_CONFIG="$(cat ~/.kube/config | base64)" ubuntu:20.04 /bin/bash -c 'touch /kube-config/config && echo "$KUBE_DATA_CONFIG" | base64 --decode >> /kube-config/config'
      # node must be labeled as required by ML Lab
      - name: label-master-node
        run: minikube kubectl -- label node minikube role=master
      # build the images, copy them to minikube and then execute build again and test
      - name: run-build-scripts
        uses: ./.github/actions/build-environment
        with:
          build_args: "--make --force --version 0.0.0 --skipt-path services/lab-workspace --skip-path services/simple-workspace-service"
          working_directory: ${{ env.WORKING_DIRECTORY }}
        env:
          SERVICES_RUNTIME: k8s
          LAB_DATA_ROOT: /workspace/data
          KUBE_CONFIG_PATH: kube-config
          SERVICE_VERSION: 0.0.0
          SERVICE_HOST: ${{ env.LAB_SERVICE_HOST }}
      # The images have to be added to minikube
      # In LabApiTest, the image version for simple-demo-job/service is set to "latest".
      # This step only works with act but on GitHub Actions it throws an error, because access to the Docker registry is not permitted
      - name: add-images-to-minikube
        run: |
          minikube cache add lab-service:0.0.0 \
          && minikube cache add simple-demo-service:latest \
          && minikube cache add simple-demo-job:latest
      - name: run-build-scripts
        uses: ./.github/actions/build-environment
        with:
          build_args: "--make --test --force --version 0.0.0 --skip-path services"
          working_directory: ${{ env.WORKING_DIRECTORY }}
        env:
          SERVICES_RUNTIME: k8s
          LAB_DATA_ROOT: /workspace/data
          KUBE_CONFIG_PATH: kube-config
          SERVICE_VERSION: 0.0.0
          SERVICE_HOST: ${{ env.LAB_SERVICE_HOST }}
      # Clean the created artifacts to prevent pollution of host when using act
      - name: clean-landscape
        run: minikube delete; docker volume rm kube-config
